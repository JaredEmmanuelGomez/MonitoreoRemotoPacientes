<div align="center">

# ü©∫ Monitoreo Remoto de Pacientes (Stack IoT) 

</div>

## üë§ Datos del Alumno

| Campo | Detalle |
|--------|---------|
| **Nombre:** | G√≥mez Aguilar Jared Emmanuel |
| **N√∫mero de Control:** | 22210309 |
| **Materia:** | Sistemas Programables / IoT |
| **Instituto:** | Tecnol√≥gico Nacional de M√©xico ‚Äì Campus Tijuana |
| **Fecha:** | 19 Octubre 2025 |
| **Instancia AWS:** | Ubuntu Server 24.04 LTS ‚Äì EC2 t2.medium |

---

## üßæ Descripci√≥n del proyecto
El proyecto **‚ÄúMonitoreo Remoto de Pacientes‚Äù** implementa una arquitectura completa de **Internet de las Cosas (IoT)** para la captura, transmisi√≥n, almacenamiento y visualizaci√≥n en tiempo real de variables biom√©dicas cr√≠ticas, tales como **temperatura corporal, saturaci√≥n de ox√≠geno (SpO‚ÇÇ)** y **frecuencia card√≠aca**. 

Utilizando un ecosistema tecnol√≥gico moderno ‚Äî **MQTT, InfluxDB, Grafana y Python** ‚Äî el sistema simula la lectura de sensores m√©dicos conectados, publica los datos a trav√©s de un **broker MQTT (Mosquitto)**, los almacena en **InfluxDB (base de datos de series temporales)** y los visualiza mediante paneles din√°micos en **Grafana**, permitiendo el monitoreo remoto y continuo del estado fisiol√≥gico del paciente.  

- **MQTT** como canal de transmisi√≥n de telemetr√≠a  
- **InfluxDB 2.x** como base de datos de series temporales  
- **Grafana** para visualizaci√≥n en tiempo real  
- **Python (Paho + InfluxDB client)** como puente y simulador  

El sistema recopila datos de temperatura corporal, saturaci√≥n de ox√≠geno (SpO‚ÇÇ) y pulso, los almacena y los muestra en dashboards con colores de alerta basados en rangos cl√≠nicos.

La arquitectura desarrollada es **modular, escalable y de c√≥digo abierto**, lo que facilita su extensi√≥n a otros dominios como la salud preventiva, la agricultura inteligente o el monitoreo industrial.  
Su dise√±o se centra en la **transmisi√≥n eficiente, la persistencia de datos confiable** y la **visualizaci√≥n intuitiva**, integrando buenas pr√°cticas de desarrollo, seguridad y documentaci√≥n profesional.

---

### ‚öôÔ∏è Objetivos Espec√≠ficos

1. **Configurar un entorno de comunicaci√≥n IoT** utilizando el protocolo MQTT con un broker Mosquitto funcional.  
2. **Simular sensores biom√©dicos** en Python que generen lecturas realistas de temperatura, SpO‚ÇÇ y pulso card√≠aco.  
3. **Implementar un bridge MQTT‚ÄìInfluxDB** para recibir, procesar y almacenar los datos en tiempo real.  
4. **Visualizar m√©tricas m√©dicas** en paneles personalizados de Grafana con umbrales cl√≠nicos de colores.  
5. **Documentar exhaustivamente** cada fase del proceso, asegurando replicabilidad y trazabilidad del proyecto.

---

### üåê Alcance

El sistema actualmente simula un paciente (ID: 001), pero el dise√±o permite escalar f√°cilmente a m√∫ltiples dispositivos, usuarios y organizaciones.  
Se pueden agregar sensores f√≠sicos, cifrado TLS, autenticaci√≥n MQTT, y exportar datos a entornos de an√°lisis o aprendizaje autom√°tico.  

> üß† *Este proyecto no solo mide datos: los transforma en informaci√≥n m√©dica valiosa para la toma de decisiones en tiempo real.*

---

## üèóÔ∏è Arquitectura del sistema

```mermaid
graph TD
    A[Sensores Biomedicos - Simulados o Reales] -->|Datos JSON| B[Cliente MQTT - Android MQTT Client o Python Paho]
    B -->|Publica y Suscribe| C[(Broker MQTT - Eclipse Mosquitto)]
    C -->|Topico pacientes/001/#| D[Bridge Python - bridge_mqtt_influx.py]
    D -->|Escritura API| E[(InfluxDB - Base de Datos Time Series)]
    E -->|Consulta Token Flux| F[Grafana Dashboard - Visualizacion Tiempo Real]
    F -->|Dashboard Web| G[Usuario Medico o Administrador]

    subgraph AWS_EC2 [AWS EC2 Instance - Ubuntu 24.04 LTS]
        C
        D
        E
        F
    end

    subgraph Dispositivo_IoT [Smartphone o Cliente IoT]
        A
        B
    end

```
---

# üß† Manual de Ejecuci√≥n y Supervisi√≥n del Sistema

El siguiente bloque resume **todos los comandos relevantes** para volver a poner en marcha el sistema completo, verificar su estado, enviar datos de prueba y visualizar la informaci√≥n en **Grafana**.

---

## ‚öôÔ∏è 1. Activar los servicios principales del stack IoT

Ejecuta estos comandos para iniciar todos los servicios base (Mosquitto, InfluxDB y Grafana):

```bash
sudo systemctl start mosquitto
```

<img width="951" height="316" alt="image" src="https://gist.github.com/user-attachments/assets/9106ce84-489d-43e6-9f2e-3509b89fc1f5" />

```bash
sudo systemctl status influxdb
```

<img width="847" height="243" alt="image" src="https://gist.github.com/user-attachments/assets/0122946a-4cd7-491b-85c5-adb6ef7f3679" />

```bash
sudo systemctl status grafana-server
```

<img width="992" height="284" alt="image" src="https://gist.github.com/user-attachments/assets/db5b87e4-b8e6-4c69-8695-5e8bde7f7676" />

üí° Si deseas que los servicios se activen autom√°ticamente al arrancar el sistema:

```bash
sudo systemctl enable mosquitto
sudo systemctl enable influxdb
sudo systemctl enable grafana-server
```

Para detenerlos:

```bash
sudo systemctl stop mosquitto influxdb grafana-server
```

---

## üß∞ Instalaci√≥n y Configuraci√≥n del Entorno Python (Cliente MQTT)

A continuaci√≥n se detallan los pasos para configurar el entorno de trabajo en **Ubuntu 24.04 LTS**,  
instalar las dependencias necesarias y crear el **simulador MQTT en Python**.

---

### üîπ 1. Actualizar el sistema e instalar Python 3 + pip

Ejecuta los siguientes comandos para asegurarte de que tu entorno tiene Python 3 y pip correctamente instalados:

```bash
sudo apt update
sudo apt install -y python3 python3-pip
```

Esto asegura que tienes Python y pip listos.

### üîπ 2. Crear un entorno virtual para el proyecto

El entorno virtual permite aislar las dependencias del proyecto y evitar conflictos con otros entornos de Python del sistema.

```
sudo apt install -y python3-venv
python3 -m venv iot-env
```
üß† El entorno iot-env almacenar√° todas las librer√≠as necesarias para este proyecto IoT.

### üîπ 3. Activar el entorno virtual

```
source iot-env/bin/activate
```

Cuando veas el prefijo (iot-env) en la l√≠nea de comandos, el entorno estar√° activo.
Todo lo que instales con pip a partir de este momento quedar√° dentro de este entorno aislado.

Para desactivarlo:

```
deactivate
```

### üîπ 4. Instalar la librer√≠a Paho MQTT

Instala la librer√≠a oficial de Python para comunicaci√≥n con brokers MQTT (Eclipse Paho):

```
pip install paho-mqtt
```

Verifica que se haya instalado correctamente:

```
pip show paho-mqtt
```

Deber√≠as obtener una salida similar a:

```
Name: paho-mqtt
Version: 1.6.x
Summary: MQTT client library
```

### üîπ 5. Crear el script del simulador MQTT

Abre un nuevo archivo para el simulador de datos:

```
nano simulador_mqtt.py
```

Dentro del editor, podr√°s escribir o pegar el c√≥digo del simulador que publica datos m√©dicos (temperatura, SpO‚ÇÇ y pulso) hacia tu broker MQTT.

---

## ü©∫ Desarrollo del Simulador de Datos M√©dicos (Cliente MQTT en Python)

Este script genera lecturas simuladas de un paciente (temperatura corporal, saturaci√≥n de ox√≠geno y pulso card√≠aco)  
y las publica peri√≥dicamente en un **Broker MQTT (Mosquitto)**, imitando el funcionamiento de sensores biom√©dicos reales.

---

```
import paho.mqtt.client as mqtt
import random
import time

# ======== CONFIGURACI√ìN DEL BROKER ========
BROKER = "localhost"   # Cambia a la IP de tu instancia o la IP de Tailscale si vas a usarla
PORT = 1883            # Puerto del broker (usa 8883 si tienes TLS activado)
TOPIC_BASE = "pacientes/001"  # ID del paciente simulado

# ======== CREAR CLIENTE MQTT ========
client = mqtt.Client(client_id="SimuladorSensor001")

# Si tu broker tiene usuario y contrase√±a, descomenta esto:
# client.username_pw_set("usuario", "contrase√±a")

# ======== CONEXI√ìN AL BROKER ========
print(f"Conectando al broker MQTT {BROKER}:{PORT} ...")
client.connect(BROKER, PORT, keepalive=60)
client.loop_start()
print("Conexi√≥n exitosa ‚úÖ")

# ======== SIMULADOR DE DATOS ========
try:
    while True:
        temperatura = round(random.uniform(36.0, 38.5), 2)
        spo2 = random.randint(90, 100)
        pulso = random.randint(60, 100)

        client.publish(f"{TOPIC_BASE}/temperatura", temperatura, qos=1)
        client.publish(f"{TOPIC_BASE}/spo2", spo2, qos=1)
        client.publish(f"{TOPIC_BASE}/pulso", pulso, qos=1)

        print(f"Publicado ‚Üí Temp: {temperatura}¬∞C | SpO2: {spo2}% | Pulso: {pulso} bpm")
        time.sleep(5)

except KeyboardInterrupt:
    print("Finalizando simulador...")
    client.loop_stop()
    client.disconnect()
```
---

### üîπ Explicaci√≥n del C√≥digo

| Secci√≥n | Descripci√≥n |
|----------|--------------|
| **Importaci√≥n de librer√≠as** | `paho.mqtt.client` gestiona la conexi√≥n MQTT, `random` genera valores aleatorios y `time` controla los intervalos de env√≠o. |
| **Configuraci√≥n del Broker** | Se define la direcci√≥n del broker MQTT (`localhost` si se ejecuta en el mismo servidor, o IP de Tailscale si es remoto). |
| **Cliente MQTT** | Se crea una instancia del cliente con un `client_id` identificando el simulador (por ejemplo, `SimuladorSensor001`). |
| **Conexi√≥n al broker** | Se conecta al servidor MQTT en el puerto 1883 y se inicia el loop de comunicaci√≥n con `loop_start()`, manteniendo la sesi√≥n activa. |
| **Simulaci√≥n de datos** | En un ciclo infinito (`while True`), se generan valores aleatorios dentro de rangos fisiol√≥gicos normales: |
|  | ‚Ä¢ **Temperatura corporal:** entre `36.0` y `38.5 ¬∞C` |
|  | ‚Ä¢ **Saturaci√≥n de ox√≠geno (SpO‚ÇÇ):** entre `90 %` y `100 %` |
|  | ‚Ä¢ **Pulso card√≠aco:** entre `60` y `100 bpm` |
| **Publicaci√≥n de mensajes** | Cada valor se publica en su t√≥pico MQTT correspondiente: `pacientes/001/temperatura`, `pacientes/001/spo2`, y `pacientes/001/pulso`. |
| **Control del ciclo** | `time.sleep(5)` define el intervalo de env√≠o de datos (cada 5 segundos). Puedes modificar este valor para mayor o menor frecuencia. |
| **Interrupci√≥n manual** | Si presionas `Ctrl + C`, el programa captura la interrupci√≥n con `KeyboardInterrupt`, detiene el loop y cierra la conexi√≥n limpiamente con `disconnect()`. |
| **QoS (Quality of Service)** | Se utiliza **QoS 1**, lo que garantiza que cada mensaje publicado llegue al menos una vez al broker MQTT, aumentando la confiabilidad. |
| **Extensi√≥n futura** | Se puede agregar autenticaci√≥n con usuario y contrase√±a o cifrado TLS (puerto 8883) para mejorar la seguridad en la transmisi√≥n. |

---

## üß™ Ejecuci√≥n del Simulador MQTT y Evidencias

Una vez configurado todo el entorno, ejecuta el simulador con el siguiente comando:

```bash
python3 simulador_mqtt.py
```

Si la conexi√≥n con el broker MQTT (Mosquitto) fue exitosa, ver√°s una salida similar en la terminal:

Conectando al broker MQTT localhost:1883 ...
Conexi√≥n exitosa ‚úÖ
Publicado ‚Üí Temp: 36.74¬∞C | SpO2: 97% | Pulso: 79 bpm
Publicado ‚Üí Temp: 37.21¬∞C | SpO2: 95% | Pulso: 82 bpm
...

## üß™ Ejecuci√≥n del Simulador MQTT y Evidencia

La siguiente imagen muestra la ejecuci√≥n del simulador MQTT en la terminal,
enviando lecturas simuladas de temperatura, SpO‚ÇÇ y pulso hacia el broker.

<img width="457" height="483" alt="image" src="https://gist.github.com/user-attachments/assets/ec760206-ff05-406b-be48-9854ebab13e1" />

---

## üß© Comunicaci√≥n Bidireccional ‚Äì MQTT Publicador y Suscriptor

En esta captura se observan ambas terminales trabajando simult√°neamente:

* **Derecha:** Ejecuci√≥n del comando ```python3 simulador_mqtt.py (publicador).```

* **Izquierda:** Ejecuci√≥n del comando ```mosquitto_sub -t "pacientes/001/#" -v (suscriptor).```

<img width="1391" height="980" alt="image" src="https://gist.github.com/user-attachments/assets/5ff6784c-13c0-4a88-8f2f-53709d444741" />

Esto demuestra el flujo correcto de datos del cliente simulador hacia el broker MQTT,
y su recepci√≥n en tiempo real por los suscriptores.

üí° El cuadro resaltado indica el intercambio activo de mensajes MQTT, evidenciando la comunicaci√≥n funcional.

---

## üåê Arquitectura MQTT en acci√≥n

En el sistema se usan dos instancias diferenciadas, mostrando el comportamiento del modelo cliente-servidor.

### üñ•Ô∏è Instancia 1 ‚Üí Mosquitto Broker (Servidor Central)

Aqu√≠ se ejecuta el broker MQTT que recibe y distribuye los mensajes de los clientes.

<img width="1052" height="268" alt="image" src="https://gist.github.com/user-attachments/assets/f232141c-de6d-4b5e-bdd3-1c733610e7a1" />

üîÅ El broker act√∫a como intermediario, asegurando la entrega de mensajes entre todos los clientes conectados.

### üì≤ Instancia 2 ‚Üí Simulador MQTT (Cliente Remoto)

<img width="562" height="385" alt="image" src="https://gist.github.com/user-attachments/assets/16fb2c12-ef5c-4bd2-9263-fad073a0d6a3" />

Desde esta instancia se ejecuta el simulador en Python, encargado de enviar lecturas peri√≥dicas al broker.

‚úÖ Cada env√≠o corresponde a una lectura biom√©dica enviada exitosamente y almacenada despu√©s en InfluxDB mediante el bridge Python.

---

## üíæ Integraci√≥n con InfluxDB ‚Äì Base de Datos de Series Temporales

Una vez establecida la comunicaci√≥n MQTT, el siguiente paso es **persistir los datos** en una base de datos optimizada para series temporales.  
En este caso, se utiliza **InfluxDB 2.x**, ejecutado dentro de la misma instancia AWS Ubuntu 24.04 LTS.

---

### ‚öôÔ∏è Verificaci√≥n del Servicio InfluxDB 

Al ingresar desde el navegador en la direcci√≥n http://<IP>:8086, se accede al panel principal de InfluxDB. 
Inicialmente, el bucket aparece vac√≠o antes de realizar la primera inserci√≥n de datos desde el script Python.

<img width="1917" height="906" alt="image" src="https://gist.github.com/user-attachments/assets/ff1cf22c-3efe-4785-85c1-21d0351e318a" />

üí° Aqu√≠ se gestionan los buckets, tokens, organizaciones y las consultas con lenguaje Flux. 
   
---

Antes de conectar el bridge MQTT con InfluxDB, activa el entorno virtual y a√±ade la librer√≠a oficial:

```
source ~/iot-env/bin/activate
pip install influxdb-client
```
    
üß† El paquete influxdb-client permite enviar datos a InfluxDB 2.x mediante la API oficial, con autenticaci√≥n por token.

---
### ‚öôÔ∏è Verificaci√≥n del Servicio InfluxDB 
    
Abre el archivo del bridge que ser√° responsable de recibir los datos publicados por el simulador
y almacenarlos en el bucket configurado:
   
```
nano simulador.py
```  
En este script se implementa el cliente MQTT y la conexi√≥n con InfluxDB para escribir datos en tiempo real.
La estructura incluye:

* Suscripci√≥n al t√≥pico pacientes/001/#.

* Conversi√≥n del payload recibido a valores num√©ricos.

* Creaci√≥n de puntos InfluxDB con etiquetas (paciente) y campos (temperatura, spo2, pulso).

* Escritura autom√°tica de cada lectura en la base de datos.
```
# simulador.py
import os
import warnings
import time
import random
from datetime import datetime
import paho.mqtt.client as mqtt
from influxdb_client import InfluxDBClient, Point, WriteOptions

warnings.filterwarnings("ignore", category=DeprecationWarning)

# ======== CONFIGURACI√ìN MQTT ========
BROKER = "localhost"
PORT = 1883
TOPIC = "pacientes/001/#"

# ======== CONFIGURACI√ìN INFLUXDB ========
INFLUX_URL = "http://localhost:8086"
INFLUX_TOKEN = "TOKEN_INFLUXDB"
INFLUX_ORG = "SistemasProgramables"
INFLUX_BUCKET = "bucket"

# ======== CONFIGURACI√ìN DEL BRIDGE ========
INTERVALO_SIMULACION = 15  # segundos
ULTIMO_MENSAJE = time.time()

# ======== CONEXI√ìN A INFLUXDB ========
try:
    client_influx = InfluxDBClient(url=INFLUX_URL, token=INFLUX_TOKEN, org=INFLUX_ORG)
    write_api = client_influx.write_api(write_options=WriteOptions(batch_size=1))
    print("‚úÖ Conexi√≥n establecida con InfluxDB")
except Exception as e:
    print(f"‚ùå Error conectando a InfluxDB: {e}")
    exit(1)

# ======== FUNCI√ìN PARA ESCRIBIR DATOS ========
def escribir_dato(metric, value, paciente="001"):
    try:
        point = (
            Point("signos_vitales")
            .tag("paciente", paciente)
            .field(metric, value)
            .time(datetime.utcnow())
        )
        write_api.write(bucket=INFLUX_BUCKET, record=point)
        print(f"üíæ Guardado en InfluxDB ‚Üí {metric}: {value}")
    except Exception as e:
        print(f"‚ö†Ô∏è Error escribiendo en InfluxDB: {e}")

# ======== CALLBACK MQTT ========
def on_message(client, userdata, msg):
    global ULTIMO_MENSAJE
    payload = msg.payload.decode("utf-8").strip()
    parts = msg.topic.split("/")
    paciente = parts[1] if len(parts) > 1 else "desconocido"
    metric = parts[2] if len(parts) > 2 else None

    if metric is None:
        print(f"‚ö†Ô∏è Mensaje sin m√©trica: {msg.topic} = '{payload}' ‚Üí ignorado.")
        return

    try:
        value = float(payload)
        escribir_dato(metric, value, paciente)
        ULTIMO_MENSAJE = time.time()
    except ValueError:
        print(f"‚ö†Ô∏è Valor inv√°lido recibido ‚Üí {msg.topic}: '{payload}' (ignorado)")

# ======== MQTT CLIENT ========
mqtt_client = mqtt.Client(client_id="BridgeInflux001")
mqtt_client.on_message = on_message

try:
    mqtt_client.connect(BROKER, PORT, keepalive=60)
    mqtt_client.subscribe(TOPIC, qos=1)
    print(f"üì° Suscrito al t√≥pico: {TOPIC}")
except Exception as e:
    print(f"‚ùå Error conectando al broker MQTT: {e}")
    exit(1)

mqtt_client.loop_start()

# ======== SIMULADOR AUTOM√ÅTICO ========
try:
    while True:
        tiempo_actual = time.time()
        # Si no han llegado mensajes en INTERVALO_SIMULACION segundos, generar datos simulados
        if tiempo_actual - ULTIMO_MENSAJE > INTERVALO_SIMULACION:
            temperatura = round(random.uniform(36.0, 38.0), 2)
            spo2 = random.randint(92, 100)
            pulso = random.randint(60, 100)

            print("ü©∫ No se detectaron datos recientes ‚Äî generando simulaci√≥n...")
            escribir_dato("temperatura", temperatura)
            escribir_dato("spo2", spo2)
            escribir_dato("pulso", pulso)
            ULTIMO_MENSAJE = tiempo_actual

        time.sleep(3)
except KeyboardInterrupt:
    print("üö™ Programa finalizado por el usuario.")
    mqtt_client.loop_stop()
    client_influx.close()

```

### üìä Resultado ‚Äì InfluxDB con Datos Recibidos

Una vez ejecutado el bridge (python3 simulador.py), los datos del simulador comienzan a registrarse autom√°ticamente.

<img width="1919" height="910" alt="image" src="https://gist.github.com/user-attachments/assets/45a391f2-39aa-4e70-8ea9-4f51fe5e3684" />

üìà Se observan los datos de temperatura, SpO‚ÇÇ y pulso registrados en el bucket ‚Äúbucket‚Äù, confirmando la persistencia correcta de la informaci√≥n.

---
    
## üß© Ejecuci√≥n del Bridge MQTT ‚Üí InfluxDB y Evidencia de Persistencia de Datos

Una vez configurado el bridge `simulador.py`, se ejecuta el siguiente comando para iniciar la transferencia de datos en tiempo real desde el broker MQTT hacia la base de datos InfluxDB:
    
```bash
python3 simulador.py
```
    
Durante la ejecuci√≥n, se observan los mensajes que confirman la simulaci√≥n de los datos m√©dicos y su escritura en la base de datos.

## üß© Ejecuci√≥n del Bridge MQTT ‚Üí InfluxDB y Evidencia de Persistencia de Datos    

En la siguiente imagen se puede ver la instancia de Ubuntu en AWS ejecutando el bridge Python,
simulando los datos de temperatura, SpO‚ÇÇ y pulso, y confirmando la recepci√≥n exitosa de cada medici√≥n.
    
<img width="633" height="477" alt="image" src="https://gist.github.com/user-attachments/assets/52da8e03-abe1-4046-9313-d15848b78cad" />
    
‚öôÔ∏è Cada l√≠nea indica que un conjunto de valores ha sido publicado por el simulador MQTT y almacenado correctamente en InfluxDB.

## üìä Verificaci√≥n de Datos en InfluxDB 
   
Las siguientes capturas evidencian c√≥mo los datos simulados se registran dentro del bucket configurado en InfluxDB,
correspondientes a los tres par√°metros monitoreados: pulso, SpO‚ÇÇ y temperatura corporal.

üíì Datos de Pulso 
    
<img width="1073" height="420" alt="image" src="https://gist.github.com/user-attachments/assets/4f800dc9-08b2-4703-b7ff-f10260134154" />

üí° Cada punto representa una lectura del pulso card√≠aco (en BPM) enviada por el simulador y registrada en el bucket.  
 
ü´Å Datos de Saturaci√≥n de Ox√≠geno (SpO‚ÇÇ)
    
<img width="1621" height="315" alt="image" src="https://gist.github.com/user-attachments/assets/df73e7cc-66df-49fa-b8e7-c0e4b39b18c5" />
    
üìà Se observa la variaci√≥n natural de las lecturas simuladas de SpO‚ÇÇ, con valores entre 90 % y 100 %, confirmando la persistencia en tiempo real.

üå°Ô∏è Datos de Temperatura Corporal
    
<img width="1590" height="282" alt="image" src="https://gist.github.com/user-attachments/assets/fc0fbab4-20e8-4418-9fe4-59c0cc4e3457" />

üî• Lecturas generadas por el simulador de temperatura corporal (rango 36.0 ¬∞C ‚Äì 38.5 ¬∞C). Cada registro es enviado al broker MQTT y almacenado autom√°ticamente por el bridge.

## üì≤ Verificaci√≥n Adicional desde MQTT Client
Para comprobar la bidireccionalidad del sistema, se realiz√≥ una prueba directa desde la aplicaci√≥n m√≥vil MQTT Client.
Antes de que transcurrieran los 15 segundos de espera del simulador, se enviaron datos manuales al t√≥pico correspondiente.
     
<img width="339" height="767" alt="image" src="https://gist.github.com/user-attachments/assets/59280964-183d-41dd-bed6-5f779aa480eb" />
    
üì° Los valores publicados manualmente fueron recibidos y almacenados correctamente, demostrando la robustez del canal MQTT.
 
## üßæ Identificaci√≥n de Datos Manuales
En esta imagen se destacan los puntos manuales que fueron enviados directamente desde el cliente MQTT, diferenci√°ndolos de los generados autom√°ticamente por el simulador.
<img width="564" height="236" alt="image" src="https://gist.github.com/user-attachments/assets/be02ba72-07f9-41a6-9d7d-70a984f07624" />

üß† Esta evidencia demuestra que el sistema IoT no solo almacena datos autom√°ticos del simulador, sino tambi√©n lecturas ingresadas manualmente desde cualquier cliente MQTT autenticado.
    
---

## üìä Integraci√≥n con Grafana ‚Äì Visualizaci√≥n en Tiempo Real
    
Con los datos ya almacenados en InfluxDB, la etapa final del proyecto consiste en visualizar las m√©tricas biom√©dicas (temperatura, SpO‚ÇÇ y pulso) en **Grafana**, generando paneles tipo *Gauge* que reflejan el estado del paciente en tiempo real.

---
    
## üß≠ Interfaz de Inicio de Grafana
Accede desde el navegador a:
    
```bash
http://<IP_PUBLICA>:3000
```
Inicio de sesi√≥n por defecto:
* **Usuario:** admin
* **Contrase√±a:** admin (se recomienda cambiarla al primer acceso)
 
üß† Grafana ofrece una interfaz moderna, ideal para crear dashboards IoT personalizados con datos provenientes de InfluxDB.
    
<img width="1919" height="1002" alt="image" src="https://gist.github.com/user-attachments/assets/85c0708f-a727-4dcd-9ddf-2544ad219ed1"/>

## üß© Conexi√≥n entre Grafana e InfluxDB
 
En el men√∫ lateral de Grafana, ve a Configuration ‚Üí Data Sources ‚Üí Add data source,
y selecciona InfluxDB. Configura los siguientes par√°metros:
    
<img width="1919" height="473" alt="image" src="https://gist.github.com/user-attachments/assets/94b97c86-8d8e-4bbc-8eab-49c8959a36db" />
    
| Campo              | Valor                   |
| ------------------ | ----------------------- |
| **Query Language** | Flux                    |
| **URL**            | `http://localhost:8086` |
| **Organization**   | `SistemasProgramables`  |
| **Token**          | (tu token de InfluxDB)  |
| **Default Bucket** | `bucket`                |    
    
üí° Se selecciona Flux porque InfluxDB 2.x utiliza este nuevo lenguaje de consultas.

Al hacer clic en Save & Test, debe aparecer el mensaje:
    
 ```bash
Data source is working
```
<img width="906" height="266" alt="image" src="https://gist.github.com/user-attachments/assets/4dd6e09f-dcbd-423b-b495-6c2778b9d656" />
    
‚úÖ Grafana ahora est√° conectado correctamente con la base de datos InfluxDB.
    
 ## üìà Creaci√≥n de Paneles y Consultas Flux
    
En los paneles tipo Gauge, se configuraron los siguientes umbrales cl√≠nicos:
    
 | M√©trica         | Unidad | Rango  | Colores                        |
| --------------- | ------ | ------ | ------------------------------ |
| üå°Ô∏è Temperatura | ¬∞C     | 35‚Äì40  | Verde / Amarillo / Rojo        |
| ü´Å SpO‚ÇÇ         | %      | 80‚Äì100 | Rojo / Amarillo / Verde        |
| üíì Pulso        | bpm    | 40‚Äì130 | Azul / Verde / Amarillo / Rojo |
    
## üìà Interpretaci√≥n Cl√≠nica de los Paneles Gauge en Grafana
    
Cada panel del dashboard en Grafana representa una variable fisiol√≥gica cr√≠tica.  
Los colores de los medidores (*Gauge Panels*) indican los **umbrales cl√≠nicos** definidos con base en valores normales del cuerpo humano.  
Esta clasificaci√≥n permite detectar de forma visual si un paciente se encuentra estable o en riesgo.
    
### üå°Ô∏è Temperatura Corporal (¬∞C)

| Rango | Color | Significado | Interpretaci√≥n |
|--------|--------|-------------|----------------|
| **35.0 ‚Äì 37.5 ¬∞C** | üü© Verde | Normal | Temperatura corporal estable. |
| **37.6 ‚Äì 38.5 ¬∞C** | üü® Amarillo | Fiebre leve | Posible respuesta inmunol√≥gica, infecci√≥n o inflamaci√≥n leve. |
| **> 38.5 ¬∞C** | üü• Rojo | Fiebre alta / riesgo | Requiere vigilancia m√©dica; indica posible infecci√≥n activa. |

> üí° *El rango normal de temperatura corporal en adultos oscila entre 36.0 y 37.4 ¬∞C.*
    
---
    
### ü´Å Saturaci√≥n de Ox√≠geno (SpO‚ÇÇ %)

| Rango | Color | Significado | Interpretaci√≥n |
|--------|--------|-------------|----------------|
| **95 ‚Äì 100 %** | üü© Verde | Normal | Oxigenaci√≥n adecuada en sangre. |
| **91 ‚Äì 94 %** | üü® Amarillo | Leve hipoxia | Posible dificultad respiratoria o fatiga. |
| **80 ‚Äì 90 %** | üü• Rojo | Hipoxia moderada/grave | Riesgo alto; requiere intervenci√≥n m√©dica. |
| **< 80 %** | ‚ö´ Negro | Cr√≠tica | Falta severa de ox√≠geno; situaci√≥n potencialmente mortal. |

> ü©∏ *En pacientes con COVID-19 o enfermedades pulmonares, valores < 94 % son una alerta de desaturaci√≥n.*

---
                                                                       
### üíì Frecuencia Card√≠aca (Pulso - bpm)

| Rango | Color | Significado | Interpretaci√≥n |
|--------|--------|-------------|----------------|
| **60 ‚Äì 100 bpm** | üü© Verde | Normal | Ritmo card√≠aco saludable en reposo. |
| **40 ‚Äì 59 bpm** | üü¶ Azul | Bradicardia | Ritmo lento; puede ser normal en atletas, o indicar disfunci√≥n card√≠aca. |
| **101 ‚Äì 120 bpm** | üü® Amarillo | Taquicardia leve | Estr√©s, fiebre o deshidrataci√≥n. |
| **> 120 bpm** | üü• Rojo | Taquicardia severa | Emergencia m√©dica; posible insuficiencia card√≠aca o shock. |

> ‚ù§Ô∏è *El pulso normal en reposo var√≠a seg√∫n la edad y condici√≥n f√≠sica, pero 60‚Äì100 bpm es el rango general saludable.*
    
### üîé Conclusi√≥n Cl√≠nica de los Rangos

- **Verde ‚Üí Estabilidad fisiol√≥gica:** el paciente se encuentra dentro de par√°metros normales.  
- **Amarillo ‚Üí Vigilancia preventiva:** cambios leves que pueden indicar inicio de complicaci√≥n.  
- **Rojo ‚Üí Alerta m√©dica:** condici√≥n potencialmente peligrosa; debe atenderse.  
- **Azul/Negro ‚Üí Estado cr√≠tico:** requiere atenci√≥n inmediata o reevaluaci√≥n del sensor.

---

Evidencia de la creaci√≥n de las gr√°ficas con las consultas Flux:
    
<img width="1919" height="883" alt="image" src="https://gist.github.com/user-attachments/assets/9583c28a-5bf8-4b7c-b591-442d9270a4e4" />

## üîÑ Gr√°ficos Din√°micos ‚Äì Datos en Tiempo Real
En las siguientes im√°genes se evidencia c√≥mo los valores de los sensores var√≠an din√°micamente,
reflej√°ndose instant√°neamente en los paneles de Grafana.
    
<img width="838" height="749" alt="image" src="https://gist.github.com/user-attachments/assets/2681777b-4b42-493d-ac5f-66bd3a48e54e" />

<img width="935" height="778" alt="image" src="https://gist.github.com/user-attachments/assets/4d52b407-6c6f-41ad-995a-30ce4385854a" />

üîÅ Los paneles se actualizan autom√°ticamente cada 5 segundos, mostrando lecturas en tiempo real desde el bridge MQTT.
    
    
 ## üß≠ Conclusi√≥n Final

El proyecto **Monitoreo Remoto de Pacientes** demostr√≥ la integraci√≥n funcional del **stack IoT moderno** compuesto por:

**MQTT ‚Üí InfluxDB ‚Üí Grafana**

A trav√©s de este desarrollo se logr√≥ establecer un flujo continuo de informaci√≥n:
1. **Captura y simulaci√≥n de datos m√©dicos** mediante sensores virtuales en Python.  
2. **Transmisi√≥n eficiente y confiable** a trav√©s del protocolo MQTT usando el broker Mosquitto.  
3. **Persistencia estructurada de datos** en InfluxDB, optimizada para series temporales.  
4. **Visualizaci√≥n din√°mica y anal√≠tica** en Grafana, con paneles en tiempo real y umbrales cl√≠nicos.

---

### üåê Impacto y Alcance Tecnol√≥gico

Esta arquitectura IoT no solo permite el monitoreo remoto de pacientes,  
sino que puede **adaptarse f√°cilmente a m√∫ltiples escenarios de la vida real**, tales como:

- üè≠ **Monitoreo industrial:** control de temperatura, vibraci√≥n o humedad en plantas de producci√≥n.  
- üå± **Agricultura inteligente:** seguimiento del nivel de humedad del suelo, luz y nutrientes.  
- üè† **Dom√≥tica:** registro de consumo el√©ctrico, seguridad y confort en viviendas inteligentes.  
- üöó **Veh√≠culos conectados:** an√°lisis de rendimiento de motores o sensores de distancia en tiempo real.  
- üå°Ô∏è **Salud preventiva:** detecci√≥n temprana de anomal√≠as fisiol√≥gicas en pacientes cr√≥nicos.

La escalabilidad del modelo permite incorporar nuevos sensores, seguridad TLS, alertas autom√°ticas,  
e incluso algoritmos de **inteligencia artificial** para predicciones y diagn√≥sticos tempranos.

---

### üß† Reflexi√≥n T√©cnica

Durante la implementaci√≥n se reforzaron conocimientos clave en:
- Protocolos IoT (MQTT)  
- Manejo de bases de datos temporales (InfluxDB)  
- Dashboards y anal√≠tica en tiempo real (Grafana)  
- Programaci√≥n Python orientada a conectividad y automatizaci√≥n  

Este ejercicio pr√°ctico consolida una base s√≥lida para futuros proyectos de **telemetr√≠a, an√°lisis de datos y sistemas distribuidos**,  
posicionando al desarrollador como capaz de dise√±ar e implementar infraestructuras IoT modernas, escalables y seguras.

---

### üöÄ Conclusi√≥n General

La experiencia demuestra que las tecnolog√≠as IoT representan una herramienta poderosa  
para **digitalizar, automatizar y mejorar la toma de decisiones en entornos reales**.  

El mismo principio que permiti√≥ monitorear los signos vitales de un paciente  
puede ser aplicado para construir **ciudades inteligentes, redes energ√©ticas sostenibles o sistemas m√©dicos interconectados**.  

> üí° *El Internet de las Cosas no solo conecta dispositivos: conecta informaci√≥n, decisiones y personas.*

 
